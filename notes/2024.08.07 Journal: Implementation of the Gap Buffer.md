### `07 AUG 2024`  Journal: Implementation of the Gap Buffer
This will be a working log on my understanding, and implementation, of the Gap Buffer as I come to research and build it.

[_Concept_](<http://t>)  
Based solely on the page I read from the paper mentioned in the [05 AUG 2024 Journal](../"2024.08.05%20Journal:%20Potential%20Data%20Structures.md"), I imagine it would be implemented something like the following. You initialize an `std::vector<char>` of size 0 when the constructor is called. Then, if there is a file present, you resize the vector to be the size of the file (in terms of number of characters) plus the size of the gap span, which I will define—*I am unsure how big the gap span should be or how even to find out*. Afterwards, you push all the file characters into the buffer. Naturally, since the user will want to extend their text, the cursor should default to after the last character—*this kinda muddles where I think the gap should be / how it should operate but this makes sense to me conceptually*. As the user types, characters should be slotted into the available space of the gap span, left-to-right, and the value (gapStart) tracking the gap should be incremented accordingly. If the cursor is moved, the new, reduced gap span should move to it, passing characters from the back span to the front span, or vice-versa, accordingly. When the gap span fills completely, the buffer should be resized (**refer to Q1 below**). Moving the cursor should just move the gap span accordingly, left or right; what is unknown is how jumping up and down lines should be handled. The insertText() function could maybe repeatedly call the insertCharacter() function. The deleteText() function, I assume, would increase the gap span to include the deleted characters: "reading the text" to display it should skip the gap span, based on the gapStart and gapEnd values.

[_A Few Questions_](<http://t>)  
1. When the text allocations exceed the size of the buffer, should the buffer be doubled or the gap span?
 - It doesn't matter. Some implementations I've seen keep the buffer (at max) the same size and only double the buffer's size when there is no more existing space for the gap to "absorb" when it needs to resize. However, my implementation of doubling the size of the buffer when no space remains and allocating all that "new space" to the gap hasn't harmed the functionality in any way. I'm intentionally making it grow this way to take advantage of the amortized constant similar to std::vector but just using a normal array. Some future performance cost may make me rethink this but so far I have found any issues.
2. Should the newline characters be included in the buffer? If so, how should they be utilized? Should newlines be defined by the max line-width (defined by the GUI)?
 - Up till now, there is no reason the newline character shouldn't be included in the buffer. I don't exactly know the GUI will use that newline character in the buffer but I do know the lines should be managed by a separate (data) structure. I'll leave the buffer alone to just hold the text and worry about formatting/displaying when I get to the GUI; this logic should be separate from the data structure.
3. How would this handle storing my "special-delete characters"? Would there be a unique value that defining the bounds? Would that be handled by a formatting data structure?
 - I... have no clue.

[_Research_](<https://www.geeksforgeeks.org/gap-buffer-data-structure/>)  
Insertion functions first check if there is enough space in the gap span. If there is not, it resizes the gap span. From what I have seen, the gap span maintains the same pre-set (by the programmer) width, regardless of the new size of the buffer. As for the buffer itself, which is managed by std::vector, it doubles in size every time its memory is exceeded.

Useful links for understanding the implementation:  
  <https://github.com/lazyhacker/gapbuffer/blob/master/gap_buffer.h>  
  <https://www.geeksforgeeks.org/gap-buffer-data-structure/>  
